#summary Running JChord on open programs

= Introduction =

JChord is designed to be run on "closed" programs, where all the code is present at analysis time. However, many interesting programs are "open", with code to be added later. For example, frameworks like Tomcat and Hadoop MapReduce are open. This page discusses ways to cope.


= Details =

Often, the best way to cope is to create an explicit program that acts as a test harness for the framework of interest.  Often, you have to do some of the work by hand. But there's a tool in extra/src/chord/analyses/makestub that will do some of the work for you. 

It runs as a JChord task. It requires config option chord.stubs.toMake, which should be a list of classes to generate harnesses for. It will then write a set of classes with names of the form StubXYZ.java, to te chord output directory.

For each class XYZ, the generated harness has one method, exercise(), that takes an object of type XYZ and will call every public method on that object. 

The reason for this interface is that often, you care about which object these methods are invoked on. For instance, suppose you're building a harness to invoke RPC methods. You want to ensure that those methods are called on the concrete server object, so that values correctly flow between the remotely-invoked RPC methods and the non-remote initialization code.

Possible extensions include generating harnesses for static methods and exercising constructors.