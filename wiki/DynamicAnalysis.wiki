#summary Writing your own Dynamic Program Analysis
#labels Featured

= Step 1 =

Determine the instrumentation scheme required by your dynamic analysis, that is, the kind and format of events to be generated during an instrumented program's execution.  See class [http://chord.stanford.edu/javadoc/chord/instr/InstrScheme.html chord.instr.InstrScheme] for the kinds of supported events and their formats.

= Step 2 =

Create a class extending [http://chord.stanford.edu/javadoc/chord/project/DynamicAnalysis.html chord.project.DynamicAnalysis] and overriding the appropriate methods in it.

The only method that must be compulsorily overridden is method `getInstrScheme()` which should return an instance of the instrumentation scheme chosen in Step 1 above.  All other methods are no-ops if not overridden.

A sample such class called `MyDynamicAnalysis` is shown below:

{{{
    import chord.project.DynamicAnalysis;
    import chord.instr.InstrScheme;

    public class MyDynamicAnalysis extends DynamicAnalysis {
        InstrScheme scheme;

        public InstrScheme getInstrScheme() {
            if (scheme != null)
                return scheme;
            scheme = new InstrScheme();
            // ***TODO***: Choose (<event1>, <args1>), ... (<eventN>, <argsN>)
            // depending upon the kind and format of events required by this
            // dynamic analysis to be generated for this during an instrumented
            // program's execution.
            scheme.set<event1>(<args1>);
            ...
            scheme.set<eventN>(<argsN>);
            return scheme;
        }

        public void initAllPasses() {
            // ***TODO***: User code to be executed once and for all
            // before all instrumented program runs start.
        }

        public void doneAllPasses() {
            // ***TODO***: User code to be executed once and for all
            // after all instrumented program runs finish.
        }

        public void initPass() {
            // ***TODO***: User code to be executed once before each
            // instrumented program run starts.
        }

        public void donePass() {
            // ***TODO***: User code to be executed once after each
            // instrumented program run finishes.
        }

        // User-defined event handlers for this dynamic analysis.
        // No-ops if not overridden.
        public void process<event1'>(<args1'>) {
            // ***TODO***: User code for handling events of kind <event1'> with format <args1'>.
        }
        ...
        public void process<eventM'>(<args<M'>) {
            // ***TODO***: User code for handling events of kind <eventM'> with format <argsM'>.
        }
    }
}}}

= Step 3 =

Determine the runtime event handler for your dynamic analysis.  There are two kinds of runtime event handlers, offline and online; see package [http://chord.stanford.edu/javadoc/chord/runtime/package-summary.html chord.runtime] for more details.

For most dynamic analyses, an offline event hander suffices, in which case you don't need to do anything in this step (except that you may want to change the default values of system properties `chord.trace.pipe` and `chord.trace.block.size` for performance; see [ChordProperties] for the meaning of these properties).  Otherwise, you need to create a class extending class [http://chord.stanford.edu/javadoc/chord/runtime/Runtime.html chord.runtime.Runtime] and override the appropriate methods in it, and provide the fully-qualified name of the created class as the value of system property `chord.runtime.class` (whose default value is the class [http://chord.stanford.edu/javadoc/chord/runtime/BufferedRuntime.html chord.runtime.BufferedRuntime]).

= Step 4 =

Provide the IDs of program runs to be generated (say 1, 2, ..., N) and the command-line arguments to be used for the program in each of those runs (say `<args1>`, ..., `<argsN>`) via system properties `chord.run.ids=1,2,...,N` and `chord.args.1=<args1>`, ..., `chord.args.N=<argsN>`.

By default, `chord.run.ids=0` and `chord.args.0=""`, that is, the program will be run only once (using run ID 0) with no command-line arguments.